# SW-Lab-2024-3 Report

به نام خدا

## بخش دوم: دستور آزمایش

### گام ۱: افزودن یک روش پیام رسانی دیگر

1.	بدون آن که متدی را از واسط Messaging Service حذف کنید ، یک سرویس دیگری را به منظور ارسال پیام از تلگرام با داشتن آیدی مبدا و آیدی مقصد ایجاد کنید - به تبع آن لازم است که یک زیر کلاس برای Message به نام Telegeram Message اضافه کنید که در آن سرویس مورد استفاده قرار گیرد.
2.	سپس یک تابع برای ارسال پیام تلگرامی در واسط Message Service اضافه کنید.
3.	در بدنه‌ی تابع مذکور - مشابه با دیگر توابع پیاده سازی شده -  از یک دستور چاپ ساده بر روی صفحه نمایش استفاده کنید.
4.	در ادامه، سعی کنید که قابلیت ارسال پیام تلگرامی را نیز به برنامه اضافه کنید؛ یعنی کاری کنید که کاربر بتواند در قالب روش سوم پیام خود را با داشتن آیدی مبدا و آیدی مقصد و متن پیام، ارسال کند.
5.	تغییراتی را که در کد فعلی برنامه می‌دهید، در جدول زیر ثبت کنید و در نهایت تعداد کل تغییرات را اعلان کنید.
    - توجه: مواردی که به عنوان تغییرات باید اعلان شود شامل این موارد هستند:
      1. ساخت کلاس جدید
      2. افزودن تابع جدید به کلاس و یا واسط (برای توابع جدید صرفا اعلام تغییر کنید)
      3. هر خطوط پیاپی‌ای که در تابع main و برای افزودن یک قابلیت جدید اضافه می‌کنید. به عنوان مثال اگر سه خط را به منظور تشخیص نوع پیام اضافه می‌کنید، آن سه خط را در قالب یک تغییر اعلام کنید (البته جزییات آن را در ستون «شرحی کوتاه از تغییر» توضیح دهید).

<table dir='rtl'>
<tbody>
<tr>
<td width="64">
<p><strong>ردیف</strong></p>
</td>
<td width="198">
<p><strong>محل اعمال تغییرات (کلاس/واسط)</strong></p>
</td>
<td width="141">
<p><strong>عنوان تغییر</strong></p>
</td>
<td width="292">
<p><strong>شرحی کوتاه از تغییر</strong></p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۱</strong></p>
</td>
<td width="198">
<p>MessageService</p>
</td>
<td width="141">
<p>افزودن تابع ارسال پیام تلگرامی</p>
</td>
<td width="292">
<p>افزودن یک تابع void با عنوان sendTelegramMessage</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>۲</strong></p>
</td>
<td width="198">
<p>TelegramMessage</p>
</td>
<td width="141">
<p>افزودن کلاس مربوط به مدل پیام‌های تلگرامی</p>
</td>
<td width="292">
<p>افزودن تابع دریافت و تنظیم کردن آیدی فرستنده و گیرنده</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>۳</strong></p>
</td>
<td width="198">
<p>TelegramMessageService</p>
</td>
<td width="141">
<p>افزودن کلاس مربوط به سرویس ارسال پیام‌های تلگرامی</p>
</td>
<td width="292">
<p>افزودن تابع ارسال پیام تلگرامی به صورت هماهنگ با سرویس‌های دیگر و اضافه کردن توابع ارسال پیام تلگرام در باقی سرویس‌ها</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>۴</strong></p>
</td>
<td width="198">
<p>Main</p>
</td>
<td width="141">
<p>افزودن حالت ارسال پیام تلگرامی</p>
</td>
<td width="292">
<p>پیاده‌سازی حالت ارسال پیام تلگرامی با دریافت آیدی مبدأ و مقصد و پیام ارسالی</p>
</td>
</tr>

</tbody>
</table>

مجموع تعداد تغییرات: ۴

### گام ۲: تحلیل و وارسی برنامه از منظر تحقق و یا عدم تحقق اصول SOLID
در خصوص این برنامه‌ای که نوشته شده بود و شما یک قابلیت به آن اضافه کردید، بر اساس اصول SOLID موارد نقض و یا محقق شدن هر کدام از آن اصول را بیان کنید. در بیان موارد تحقق و نقض، علت تحقق و یا نقض را نیز به صورت کامل توضیح دهید:

<table dir='rtl'>
<tbody>
<tr>
<td rowspan="2" width="240">
<p>اصل 1</p>
<p>Single Responsibility</p>
</td>
<td width="95">
<p><strong>موارد تحقق</strong></p>
</td>
<td width="454">
<p>در صورتی که کارکردهای مجزایی برای پیام‌های SMS و Email و Telegram در نظر بگیریم، می‌توان گفت که در هر مدل ارسال پیام این اصل رعایت شده است. به طور مشخص کلاس TelegramMessage در بخش مدل‌ها یک مسئولیت واحد یعنی تنظیم‌کردن آیدی‌های مبدأ و مقصد را به عهده دارد. همچنین این اصل کلاس‌های مدل پیام Email و SMS نیز رعایت شده است.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>در بخش سرویس‌های ارسال پیام این اصل نقض شده است. زیرا در هر کلاس مربوط به سرویس‌های ارسال پیام، توابع ارسال پیام سرویس‌های دیگر نیز پیاده‌سازی شده است. همچنین در صورتی که ارسال پیام از هر نوع را به صورت واحد در نظر بگیریم، به طور کلی این اصل در طراحی کلاس‌ها نقض شده است زیرا کارکردهای متفاوت برای یک مسئولیت یکسان تعریف شده است.</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 2</p>
<p>Open-Close Principle (OCP)</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>این اصل بیان می‌کند که پیاده‌سازی ما نسبت به توسعه باز باشد و نسبت به اصلاح بخش‌های قبلی بسته. در کلاس‌های مدل مانند TelegramMessage این اصل رعایت شده است زیرا این کلاس‌ها بدون تغییر بخش‌های دیگر مدل اضافه شده‌اند.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>این اصل در پیاده‌سازی سرویس‌ها نقض شده است زیرا با اضافه کردن سرویس ارسال پیام تلگرام لازم شد که توابع ارسال پیام تلگرامی به سرویس‌های SMS و Email نیز اضافه شود.</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 3</p>
<p>Liskov Substitution Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>این اصل بیان می‌کند که زیرکلاس‌ها باید قابل جایگزینی برای کلاس‌های پایه خود باشند. مجددا این اصل در بخش کلاس‌های مدل رعایت شده است. همچنین در کلاس‌های سرویس نیز این اصل رعایت شده است.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 4</p>
<p>Interface Segregation Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>در سرویس‌های ارسال پیام، یک interface همه کاره داریم که سه سرویس آن را پیاده‌سازی می‌کنند. مشکل این سرویس آن است که در هر سرویس لازم است که توابع سرویس‌های دیگر نیز پیاده‌سازی شوند.</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 5</p>
<p>Dependency Inversion Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>مجددا در بخش کلاس‌های مدل این اصل رعایت شده است زیرا کلاس‌ها از طریق abstractionها به یکدیگر وابسته‌اند و نه پیاده‌سازی‌های آنها</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>در پیاده‌سازی سرویس‌ها این اصل نقض شده است زیرا وابستگی‌ها در سطح abstraction نیست و با تغییر یکی از سرویس‌ها نیاز است که سرویس‌های دیگر اصلاح شوند.</p>
</td>
</tr>
</tbody>
</table>

در خصوص هرکدام از موارد نقض هرکدام از اصول، یک راهکار را به منظور رفع آن مشکل ارایه داده و در جدول زیر ثبت نمایید:

<table dir='rtl'>
<tbody>
<tr>
<td width="168">
<p><strong>اصل مربوطه (از اصول </strong><strong>SOLID</strong><strong>)</strong></p>
</td>
<td width="246">
<p><strong>علت نقض</strong></p>
</td>
<td width="284">
<p><strong>راه حل پیشنهادی</strong></p>
</td>
</tr>

<tr>
<td width="168">
<p>Single Responsibility Principle</p>
</td>
<td width="246">
<p>در هر کلاس مربوط به سرویس‌های ارسال پیام، توابع ارسال پیام سرویس‌های دیگر نیز پیاده‌سازی شده است.</p>
</td>
<td width="284">
<p>یک تابع یکسان برای ارسال پیام در نظر گرفته و آن را در هر کدام از زیرکلاس‌ها extend می‌کنیم.</p>
</td>
</tr>

<tr>
<td width="168">
<p>Open-Closed Principle</p>
</td>
<td width="246">
<p>با اضافه کردن سرویس ارسال پیام تلگرام لازم شد که توابع ارسال پیام تلگرامی به سرویس‌های SMS و Email نیز اضافه شود.</p>
</td>
<td width="284">
<p>مجددا با در نظر گرفتن یک تابع یکسان برای ارسال پیام این مشکل رفع می‌شود زیرا دیگر لازم نیست در هر سرویس توابع ارسال پیام سرویس‌های دیگر پیاده‌سازی شوند.</p>
</td>
</tr>

<tr>
<td width="168">
<p>Interface Segregation Principle</p>
</td>
<td width="246">
<p>مشکل این سرویس آن است که در هر سرویس لازم است که توابع سرویس‌های دیگر نیز پیاده‌سازی شوند.</p>
</td>
<td width="284">
<p>یک راه حل آن است که رابط‌های متفاوت برای سرویس‌های ارسال پیام در نظر بگیریم. اما با پیاده‌سازی یک تابع یکسان برای ارسال پیام، این مشکل می‌تواند رفع شود.</p>
</td>
</tr>

<tr>
<td width="168">
<p>Dependency Inversion Principle</p>
</td>
<td width="246">
<p>وابستگی‌ها در سطح abstraction نیست و با تغییر یکی از سرویس‌ها نیاز است که سرویس‌های دیگر اصلاح شوند.</p>
</td>
<td width="284">
<p>با پیاده‌سازی یک تابع یکسان برای ارسال پیام‌ها مشکل وابستگی سرویس‌ها به یکدیگر برطرف می‌شود.</p>
</td>
</tr>

</tbody>
</table>

### گام ۳: اصلاح موارد نقض
در نهایت، بر اساس تحلیلی که انجام داده‌اید و راه حل‌هایی که در بخش قبل ارایه کردید، کد را اصلاح کرده و بر روی مخزن گیت‌هاب و در پوشه‌ای مجزا از گام قبل commit و push کنید. انتظار می‌رود که تمامی راه حل‌های پیشنهادی خود را بر روی این نسخه اعمال کنید و تمامی بهبودهایی که انجام می‌دهید، در جداول بخش قبل موجود باشد.

### گام ۴: بررسی مجدد تغییرات مورد نیاز
فرض کنید که گام 1 را برای کد اصلاح شده (پس از انجام گام‌های ۲ و ۳) اجرا کرده‌اید.
1. در این صورت از انجام کدام یک از تغییرات ثبت شده در جدول گام ۱ معاف خواهید شد؟
2. تعداد تغییرات مورد نیاز، چند تغییر خواهد شد؟

### گام ۵: جمع بندی
در این بخش، بیان کنید که از این گام چه نتیجه‌ای گرفته‌اید؟ و به نظر شما به کارگیری صحیح اصول SOLID در گام‌های ۳ و ۴ چه مزایایی را نسبت به حالتی دارد که این اصول رعایت نشده‌بود؟

## نحوه ارسال پروژه:
1.	گام ۱ را انجام داده و سپس کد نوشته شده‌ی خود را (با رعایت محدودیت‌های گفته شده در گام) در یک پوشه به نام Step_1_Non_SOLID ذخیره کنید و در مخزن گام ۲ قرار دهید. موارد توضیحی بایستی در بخش README مخزن قرار گیرد.
2.	گام ۲ (که بخش تحلیلی است) در فایل README مربوط به مخزن گام ۲ آورده شود (تمام جداول با فرمت داده شده و عناوین هرکدام از سوالات پرسیده شده بایستی در README آورده شود).
3.	گام ۳ که شامل بهبود است، بایستی به صورت جداگانه در پوشه دیگری به نام Step_3_With_SOLID قرار داده شود و در مخزن موجود باشد.
4.	گام ۴ نیز در قالب توضیحات در README مخزن آورده شود.
5.	گام ۵ (که نتیجه گیری است) در README مخزن آورده شود.
